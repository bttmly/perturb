#!/usr/bin/env node

// shamelessly appropriated from mocha

"use strict";

var path = require("path");

var spawn = require("child_process").spawn;
var perturb = path.join(__dirname, "_perturb");
var args = [perturb];

var bin = process.argv[0];

var timeout, ONE_MINUTE = 60 * 1000;

process.argv.slice(2).forEach(function (arg) {
  var flag = arg.split("=")[0];
  var val = arg.split("=")[1];

  switch (flag) {

  case "timeout":
    timeout = Number(val);
    if (isNaN(timeout)) throw new Error("Invalid timeout");
    return;

  case "--iojs":
    bin = "iojs";
    return;

  case "--harmony":
  case "--harmony-proxies":
  case "--harmony-collections":
  case "--harmony-generators":
  case "--harmony_shipping":
  case "--harmony_arrow_functions":
  case "--harmony_proxies":
    args.unshift(arg);
    return;

  default:
    args.push(arg);
    return;
  }

});


timeout = timeout || ONE_MINUTE;

console.log([bin].concat(args).join(" "));

var child = spawn(bin, args, {stdio: "inherit"});

child.on("exit", function (code, signal) {
  console.log("child exiting...", code);
  process.on("exit", function(){
    if (signal) {
      process.kill(process.pid, signal);
    } else {
      process.exit(code);
    }
  });
});

child.on("error", function (err) {
  console.log("child errored...", err);
});

// terminate children.
process.on("SIGINT", function () {
  child.kill("SIGINT"); // calls runner.abort()
  child.kill("SIGTERM"); // if that didn"t work, we"re probably in an infinite loop, so make it die.
  process.kill(process.pid, "SIGINT");
});

setTimeout(function () {
  console.log("Timeout exceeded.");
  child.kill("SIGINT");
}, timeout).unref();
