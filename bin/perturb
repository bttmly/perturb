#!/usr/bin/env node

// shamelessly appropriated from mocha

"use strict";

var path = require("path");

var spawn = require("child_process").spawn;
var perturb = path.join(__dirname, "_perturb");
var args = [perturb];

var bin = process.argv[0];

var timeout, ONE_MINUTE = 60 * 1000;

process.argv.slice(2).forEach(function (arg) {
  var flag = arg.split("=")[0];
  var val = arg.split("=")[1];

  switch (flag) {

  case "timeout":
    timeout = Number(val);
    if (isNaN(timeout)) throw new Error("Invalid timeout");
    return;

  case "--iojs":
    bin = "iojs";
    return;

  case "--harmony":
  case "--harmony-proxies":
  case "--harmony-collections":
  case "--harmony-generators":
  case "--harmony_shipping":
  case "--harmony_arrow_functions":
  case "--harmony_proxies":
    args.unshift(arg);
    return;

  default:
    args.push(arg);
    return;
  }

});


timeout = timeout || ONE_MINUTE;

console.log([bin].concat(args).join(" "));

var child = spawn(bin, args, {
  stdio: "inherit",
});

child.on("exit", function (code, signal) {
  console.log("child exiting...", code);
  if (signal) {
    throw new Error("Child received signal " + signal);
  }

  if (code === 0) return;

  throw new Error("Child exited with code " + code);
});

child.on("error", function (err) {
  throw err;
});

// terminate children.
process.on("SIGINT", function () {
  child.kill("SIGINT"); // calls runner.abort()
  child.kill("SIGTERM"); // if that didn"t work, we"re probably in an infinite loop, so make it die.
  throw new Error("Main process received SIGINT");
});

setTimeout(function () {
  console.log("Timeout exceeded.");
  child.kill("SIGINT");
}, timeout).unref();
